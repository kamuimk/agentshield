# AgentShield v0.2 - Code Review Action Items PRD

## Overview
AgentShield v0.1 코드 리뷰에서 도출된 P1~P3 개선 항목을 구현한다.
AgentShield는 AI 에이전트의 아웃바운드 네트워크 트래픽을 제어하는 투명 이그레스 방화벽이며,
Rust로 구현된 HTTP/HTTPS 프록시 + TOML 기반 정책 엔진이다.

## Tech Stack
- Rust (edition 2024), Tokio, clap 4.5, rusqlite 0.32, toml 0.8, serde, tracing, anyhow
- 프로젝트 구조: src/{proxy, policy, logging, cli, dlp}, templates/, tests/

---

## P1: Important Improvements (v0.2 핵심)

### 1. 프록시-로깅 연결 (SQLite 로깅 통합)
- **현재 상태**: 정책 평가 결과가 tracing으로만 로그되고 SQLite에 기록되지 않음
- **목표**: 프록시에서 정책 평가 후 모든 요청을 SQLite에 기록
- **구현 방향**:
  - `ProxyServer`에 DB path를 주입할 수 있게 확장 (`with_db_path(PathBuf)`)
  - `accept_loop`에서 SQLite Connection을 열고, 각 연결 핸들러에 전달
  - SQLite Connection은 thread-safe하지 않으므로 `Arc<Mutex<Connection>>` 사용
  - `handle_connect()`와 `handle_http_request()`에서 정책 평가 후 `logging::log_request()` 호출
  - `cmd_start()`에서 `with_db_path()` 호출하여 DB 경로 전달
- **관련 파일**: `src/proxy/mod.rs`, `src/proxy/connect.rs`, `src/main.rs`
- **테스트**: 프록시를 통해 요청을 보낸 후 SQLite DB에 로그가 기록되었는지 검증

### 2. HTTP 응답 스트리밍
- **현재 상태**: `handle_http_request()`에서 응답을 64KB 고정 버퍼로 한번만 읽음. 큰 응답이 잘림.
- **목표**: 응답을 스트리밍 방식으로 전체 전달
- **구현 방향**:
  - 현재 64KB 고정 read를 `tokio::io::copy` 양방향 스트리밍으로 변경
  - CONNECT 터널링의 양방향 copy 패턴과 동일하게 구현
  - 요청 전송 후 remote → client 방향으로 `tokio::io::copy` 사용
- **관련 파일**: `src/proxy/connect.rs` (`handle_http_request` 함수)
- **테스트**: 64KB보다 큰 응답이 정상적으로 전달되는지 검증

### 3. ASK → 승인 프롬프트 연결
- **현재 상태**: ASK 액션이 단순히 allow로 처리됨. `cli/prompt.rs`에 프롬프트 로직이 있지만 프록시와 연결되지 않음.
- **목표**: ASK 발생 시 터미널에서 사용자 승인을 받고, 승인/거부/룰 추가를 처리
- **구현 방향**:
  - `tokio::sync::mpsc` 채널로 프록시 → 메인 스레드 간 승인 요청/응답 전달
  - `AskRequest` 구조체 (요청 정보 + `tokio::sync::oneshot::Sender` 응답 채널)
  - 메인 스레드에서 stdin/stdout으로 사용자에게 프롬프트 표시
  - 타임아웃 30초, 무응답 시 deny 기본값
  - AllowOnce → 해당 요청만 통과, AddRule → config 파일에 룰 추가 후 통과
  - ProxyServer에 ask 채널을 주입 (`with_ask_channel`)
- **관련 파일**: `src/proxy/mod.rs`, `src/proxy/connect.rs`, `src/cli/prompt.rs`, `src/main.rs`
- **테스트**: ASK 정책 룰에 매칭되는 요청이 채널을 통해 승인 요청을 보내는지 검증

---

## P2: Nice-to-have Improvements

### 4. README.md 작성
- **목표**: 오픈소스 공개를 위한 README 작성
- **포함 내용**:
  - 프로젝트 한 줄 설명 + 배지 (build status, license)
  - Quick Start (install → init → template → start)
  - 정책 파일 예시
  - 아키텍처 다이어그램 (mermaid)
  - "What AgentShield is NOT" 섹션
  - Contributing 가이드
- **관련 파일**: `README.md`

### 5. GitHub Actions CI 설정
- **목표**: PR/push 시 자동 테스트, lint, format 체크
- **구현**:
  - `.github/workflows/ci.yml` 생성
  - `cargo test --all`, `cargo clippy -- -D warnings`, `cargo fmt --check`
  - ubuntu-latest, dtolnay/rust-toolchain@stable 사용
- **관련 파일**: `.github/workflows/ci.yml`

### 6. DLP 인터페이스 정의
- **현재 상태**: `src/dlp/mod.rs`와 `src/dlp/patterns.rs`가 빈 파일
- **목표**: v0.3 DLP 구현을 위한 trait 인터페이스 정의
- **구현**:
  - `DlpScanner` trait: `fn scan(&self, payload: &[u8]) -> Vec<DlpFinding>`
  - `DlpFinding` 구조체: pattern_name, matched_text, severity
  - `Severity` enum: Low, Medium, High, Critical
  - `RegexScanner` 기본 구현체 (설정에서 패턴 로드)
- **관련 파일**: `src/dlp/mod.rs`, `src/dlp/patterns.rs`
- **테스트**: RegexScanner가 API key 패턴을 탐지하는지 검증

### 7. Notification trait + Terminal 래핑
- **목표**: 알림 백엔드를 추상화하여 Terminal, Telegram, Webhook 등을 교체 가능하게 함
- **구현**:
  - `src/notification/mod.rs` - `Notifier` async trait 정의
    - `async fn send_ask(&self, req: &PromptRequest) -> Result<String>` (request_id 반환)
    - `async fn wait_response(&self, request_id: &str, timeout: Duration) -> Result<PromptDecision>`
  - `src/notification/terminal.rs` - 기존 터미널 프롬프트를 Notifier trait으로 래핑
  - config에 `[notification]` 섹션 추가: `backend = "terminal"`, `timeout_secs = 30`
- **관련 파일**: `src/notification/mod.rs`, `src/notification/terminal.rs`, `src/policy/config.rs`
- **테스트**: Terminal notifier가 stdin/stdout으로 프롬프트를 표시하는지 검증

### 8. Telegram Bot 알림 연동
- **의존성**: Task 7 (Notification trait) 완료 필요
- **목표**: ASK 이벤트 발생 시 Telegram Bot API로 사용자에게 알림, 인라인 버튼으로 승인/거부
- **구현**:
  - `src/notification/telegram.rs` - `TelegramNotifier` 구현
  - POST `https://api.telegram.org/bot<token>/sendMessage` with inline_keyboard
  - `getUpdates` polling으로 callback 응답 수신
  - 각 ASK 요청에 고유 ID 부여, callback_data에 포함하여 매핑
  - config: `[notification.telegram]` - bot_token, chat_id
- **관련 파일**: `src/notification/telegram.rs`, `src/policy/config.rs`
- **테스트**: Mock HTTP 서버로 Telegram API 호출을 검증

### 9. 시스템 allowlist (알림 채널 보호)
- **목표**: 알림 채널(Telegram API 등)이 사용자 정책에 의해 차단되지 않도록 내부 allowlist 구현
- **구현**:
  - `SYSTEM_ALLOWED_DOMAINS` 상수: `["api.telegram.org"]`
  - 사용자 정책 평가 전에 시스템 allowlist 체크
  - 시스템 허용된 도메인은 정책 평가를 스킵하고 항상 allow
  - 로깅은 수행 (action: "system-allow")
- **관련 파일**: `src/proxy/connect.rs`, `src/policy/evaluator.rs`
- **테스트**: 사용자 정책이 deny-all이어도 시스템 도메인은 허용되는지 검증

---

## P3: Code Quality

### 10. println! → tracing 통일
- **현재 상태**: `main.rs`의 CLI 출력이 `println!`을 사용. 로그 레벨 제어 불가.
- **목표**: 사용자 대면 출력은 `println!` 유지, 내부 동작 로그는 `tracing` 매크로로 통일
- **관련 파일**: `src/main.rs` 내 `cmd_start`, `cmd_stop` 등

### 11. anyhow → thiserror (라이브러리 코드)
- **현재 상태**: 라이브러리 코드(`lib.rs` 하위)에서 `anyhow`를 사용
- **목표**: 라이브러리 코드에는 `thiserror`로 커스텀 에러 타입 정의, `anyhow`는 `main.rs`에서만 사용
- **구현**:
  - `src/error.rs` 생성: `AgentShieldError` enum (`Policy`, `Config`, `Database`, `Proxy` variants)
  - 각 모듈의 `anyhow::Result`를 `Result<T, AgentShieldError>`로 변경
  - `main.rs`에서는 `anyhow`로 감싸서 사용
- **관련 파일**: 새로 생성할 `src/error.rs`, `src/` 전체 모듈

### 12. Host header injection 방어
- **현재 상태**: `parse_host_port()`에서 도메인 유효성 검증 없음
- **목표**: 도메인에 허용되지 않는 문자가 포함된 경우 요청 거부
- **구현**:
  - 도메인 유효성 검증 함수 추가 (알파벳, 숫자, 하이픈, 점만 허용)
  - 포트 범위 검증 (1-65535)
  - CONNECT에서 허용 포트 제한 옵션 (기본: 443, 8443)
- **관련 파일**: `src/proxy/connect.rs`
- **테스트**: 잘못된 도메인/포트가 거부되는지 검증
